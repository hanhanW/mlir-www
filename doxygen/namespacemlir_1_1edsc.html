<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::edsc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1edsc.html">edsc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::edsc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1edsc_1_1intrinsics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html">intrinsics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1edsc_1_1op"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc_1_1op.html">op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1edsc_1_1ops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc_1_1ops.html">ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1AffineLoopNestBuilder.html">AffineLoopNestBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="classmlir_1_1edsc_1_1AffineLoopNestBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1Append.html">Append</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1BlockBuilder.html">BlockBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1BlockBuilder.html" title="A BlockBuilder is a NestedBuilder for mlir::Block*. ">BlockBuilder</a> is a <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">mlir::Block</a>*.  <a href="classmlir_1_1edsc_1_1BlockBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1BlockHandle.html">BlockHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1BlockHandle.html" title="A BlockHandle represents a (potentially &quot;delayed&quot;) Block abstraction. ">BlockHandle</a> represents a (potentially "delayed") <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> abstraction.  <a href="classmlir_1_1edsc_1_1BlockHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1BoundsCapture.html">BoundsCapture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1edsc_1_1MemRefBoundsCapture.html" title="A MemRefBoundsCapture represents the information required to step through a MemRef. ">MemRefBoundsCapture</a> and <a class="el" href="classmlir_1_1edsc_1_1VectorBoundsCapture.html" title="A VectorBoundsCapture represents the information required to step through a Vector accessing each sca...">VectorBoundsCapture</a>.  <a href="classmlir_1_1edsc_1_1BoundsCapture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1GenericLoopNestRangeBuilder.html">GenericLoopNestRangeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template class for building scf.for and affine.loop nests from ranges.  <a href="classmlir_1_1edsc_1_1GenericLoopNestRangeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html" title="A LoopBuilder is a generic NestedBuilder for loop-like MLIR operations. ">LoopBuilder</a> is a generic <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> for loop-like MLIR operations.  <a href="classmlir_1_1edsc_1_1LoopBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1LoopNestBuilder.html">LoopNestBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to sugar building scf.for loop nests from ranges.  <a href="classmlir_1_1edsc_1_1LoopNestBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1MemRefBoundsCapture.html">MemRefBoundsCapture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1MemRefBoundsCapture.html" title="A MemRefBoundsCapture represents the information required to step through a MemRef. ">MemRefBoundsCapture</a> represents the information required to step through a MemRef.  <a href="classmlir_1_1edsc_1_1MemRefBoundsCapture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html">NestedBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves the purpose of building nested MLIR.  <a href="classmlir_1_1edsc_1_1NestedBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1OperationBuilder.html">OperationBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1ParallelLoopNestBuilder.html">ParallelLoopNestBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to sugar building scf.parallel loop nests from lower/upper bounds and step sizes.  <a href="classmlir_1_1edsc_1_1ParallelLoopNestBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html">ScopedContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to transparently handle builder insertion points by RAII.  <a href="classmlir_1_1edsc_1_1ScopedContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html" title="A StructuredIndexed represents an indexable quantity that is either: ">StructuredIndexed</a> represents an indexable quantity that is either:  <a href="structmlir_1_1edsc_1_1StructuredIndexed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html">TemplatedIndexedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html" title="A TemplatedIndexedValue brings an index notation over the template Load and Store parameters...">TemplatedIndexedValue</a> brings an index notation over the template Load and Store parameters.  <a href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1ValueBuilder.html">ValueBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1VectorBoundsCapture.html">VectorBoundsCapture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1VectorBoundsCapture.html" title="A VectorBoundsCapture represents the information required to step through a Vector accessing each sca...">VectorBoundsCapture</a> represents the information required to step through a <a class="el" href="structVector.html">Vector</a> accessing each scalar element at a time.  <a href="classmlir_1_1edsc_1_1VectorBoundsCapture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aabb586c240e934aa2564f8fb87ad9f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#aabb586c240e934aa2564f8fb87ad9f92">makeAffineLoopBuilder</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> *iv, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; ubs, int64_t step)</td></tr>
<tr class="memdesc:aabb586c240e934aa2564f8fb87ad9f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new AffineForOp and captures the associated induction variable.  <a href="#aabb586c240e934aa2564f8fb87ad9f92">More...</a><br /></td></tr>
<tr class="separator:aabb586c240e934aa2564f8fb87ad9f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a3444a010f914992cdd1340b4377a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a786a3444a010f914992cdd1340b4377a">affineLoopNestBuilder</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="memdesc:a786a3444a010f914992cdd1340b4377a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perfect nest of affine "for" loops, given the list of lower bounds, upper bounds and steps.  <a href="#a786a3444a010f914992cdd1340b4377a">More...</a><br /></td></tr>
<tr class="separator:a786a3444a010f914992cdd1340b4377a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bf263e977c58c3ce16777c46f57f94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#ac5bf263e977c58c3ce16777c46f57f94">affineLoopBuilder</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, int64_t step, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="memdesc:ac5bf263e977c58c3ce16777c46f57f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single affine "for" loop, iterating from max(lbs) to min(ubs) with the given step.  <a href="#ac5bf263e977c58c3ce16777c46f57f94">More...</a><br /></td></tr>
<tr class="separator:ac5bf263e977c58c3ce16777c46f57f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2530abadfa4b280f31ddd2f62d5db514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a2530abadfa4b280f31ddd2f62d5db514">defaultRegionBuilder</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; args)</td></tr>
<tr class="separator:a2530abadfa4b280f31ddd2f62d5db514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e10769efcd438ec5b0f315e186a033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#aa4e10769efcd438ec5b0f315e186a033">makeGenericLinalgOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a> &gt; iteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt; inputs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt; outputs, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;)&gt; regionBuilder=<a class="el" href="namespacemlir_1_1edsc.html#a2530abadfa4b280f31ddd2f62d5db514">defaultRegionBuilder</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; otherValues={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; otherAttributes={})</td></tr>
<tr class="memdesc:aa4e10769efcd438ec5b0f315e186a033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>linalg.generic</code> op with the specified <code>inputs</code>, <code>outputs</code> and <code>region</code>.  <a href="#aa4e10769efcd438ec5b0f315e186a033">More...</a><br /></td></tr>
<tr class="separator:aa4e10769efcd438ec5b0f315e186a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae731f984bb316abc10bf03d3455e952c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#ae731f984bb316abc10bf03d3455e952c">makeParallelLoopBuilder</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; steps)</td></tr>
<tr class="memdesc:ae731f984bb316abc10bf03d3455e952c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new scf::ParallelOp and captures the associated induction variables.  <a href="#ae731f984bb316abc10bf03d3455e952c">More...</a><br /></td></tr>
<tr class="separator:ae731f984bb316abc10bf03d3455e952c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea7b4f1db20f2062e7cf544465b435e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#abea7b4f1db20f2062e7cf544465b435e">makeLoopBuilder</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> *iv, <a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; iterArgsHandles, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgsInitValues)</td></tr>
<tr class="memdesc:abea7b4f1db20f2062e7cf544465b435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new scf::ForOp and captures the associated induction variable.  <a href="#abea7b4f1db20f2062e7cf544465b435e">More...</a><br /></td></tr>
<tr class="separator:abea7b4f1db20f2062e7cf544465b435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87caf90e4c0e1327e9102ffd746d77f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a87caf90e4c0e1327e9102ffd746d77f2">makeLoopBuilder</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> *iv, <a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step)</td></tr>
<tr class="separator:a87caf90e4c0e1327e9102ffd746d77f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b25568df98d20a2630e00321104b31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a71b25568df98d20a2630e00321104b31">loopNestBuilder</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; fun=nullptr)</td></tr>
<tr class="memdesc:a71b25568df98d20a2630e00321104b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapters for building loop nests using the builder and the location stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a>.  <a href="#a71b25568df98d20a2630e00321104b31">More...</a><br /></td></tr>
<tr class="separator:a71b25568df98d20a2630e00321104b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6102d86c56239570c27009fc77ccd214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a6102d86c56239570c27009fc77ccd214">loopNestBuilder</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; fun=nullptr)</td></tr>
<tr class="separator:a6102d86c56239570c27009fc77ccd214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12538f3de51ace3f31238b03ac803e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a12538f3de51ace3f31238b03ac803e6d">loopNestBuilder</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgInitValues, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; fun=nullptr)</td></tr>
<tr class="separator:a12538f3de51ace3f31238b03ac803e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca18a43d10dbe061041cb2c1190119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a11ca18a43d10dbe061041cb2c1190119">conditionBuilder</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> results, <a class="el" href="classmlir_1_1Value.html">Value</a> condition, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>()&gt; thenBody, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>()&gt; elseBody=nullptr)</td></tr>
<tr class="memdesc:a11ca18a43d10dbe061041cb2c1190119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapters for building if conditions using the builder and the location stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a>.  <a href="#a11ca18a43d10dbe061041cb2c1190119">More...</a><br /></td></tr>
<tr class="separator:a11ca18a43d10dbe061041cb2c1190119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2dc4b8bdff33328eb35e29c5d97197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a6e2dc4b8bdff33328eb35e29c5d97197">conditionBuilder</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> condition, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void()&gt; thenBody, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void()&gt; elseBody=nullptr)</td></tr>
<tr class="separator:a6e2dc4b8bdff33328eb35e29c5d97197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac5bf263e977c58c3ce16777c46f57f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bf263e977c58c3ce16777c46f57f94">&#9670;&nbsp;</a></span>affineLoopBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::edsc::affineLoopBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a single affine "for" loop, iterating from max(lbs) to min(ubs) with the given step. </p>
<p>Uses the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> and <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a> and assumes they are non-null. The optional "bodyBuilderFn" callback is called to construct the body of the loop and is passed the induction variable. The function is expected to use the builder and location stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a> at the moment of the call. The function should not create the affine terminator op, which will be added regardless of the "bodyBuilderFn" being present. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00118">118</a> of file <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00375">mlir::OpBuilder::create()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00057">mlir::edsc::ScopedContext::getContext()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>, and <a class="el" href="IR_2Builders_8cpp_source.html#l00315">mlir::Builder::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a786a3444a010f914992cdd1340b4377a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786a3444a010f914992cdd1340b4377a">&#9670;&nbsp;</a></span>affineLoopNestBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::edsc::affineLoopNestBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perfect nest of affine "for" loops, given the list of lower bounds, upper bounds and steps. </p>
<p>The three lists are expected to contain the same number of elements. Uses the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations. ">OpBuilder</a> and <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a> and assumes they are non-null. The optional "bodyBuilderFn" callback is called to construct the body of the innermost loop and is passed the list of loop induction variables, in order from outermost to innermost. The function is expected to use the builder and location stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a> at the moment of the call. The function should not create the affine terminator op, which will be added regardless of the "bodyBuilderFn" being present. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00067">67</a> of file <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00375">mlir::OpBuilder::create()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00057">mlir::edsc::ScopedContext::getContext()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00311">mlir::Builder::getDimIdentityMap()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>, <a class="el" href="Ops_8h_source.html#l00092">mlir::ConstantIndexOp::getValue()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00330">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00160">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a11ca18a43d10dbe061041cb2c1190119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca18a43d10dbe061041cb2c1190119">&#9670;&nbsp;</a></span>conditionBuilder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> mlir::edsc::conditionBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>()&gt;&#160;</td>
          <td class="paramname"><em>thenBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>()&gt;&#160;</td>
          <td class="paramname"><em>elseBody</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adapters for building if conditions using the builder and the location stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a>. </p>
<p>'thenBody' is mandatory, 'elseBody' can be omitted if the condition should not have an 'else' part. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00176">176</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00375">mlir::OpBuilder::create()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00057">mlir::edsc::ScopedContext::getContext()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>, and <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00164">wrapIfBody()</a>.</p>

</div>
</div>
<a id="a6e2dc4b8bdff33328eb35e29c5d97197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2dc4b8bdff33328eb35e29c5d97197">&#9670;&nbsp;</a></span>conditionBuilder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> mlir::edsc::conditionBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>thenBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>elseBody</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00197">197</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00375">mlir::OpBuilder::create()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00057">mlir::edsc::ScopedContext::getContext()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>, and <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00189">wrapZeroResultIfBody()</a>.</p>

</div>
</div>
<a id="a2530abadfa4b280f31ddd2f62d5db514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2530abadfa4b280f31ddd2f62d5db514">&#9670;&nbsp;</a></span>defaultRegionBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::edsc::defaultRegionBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00058">58</a> of file <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html">Builders.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00073">makeGenericLinalgOp()</a>.</p>

</div>
</div>
<a id="a71b25568df98d20a2630e00321104b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b25568df98d20a2630e00321104b31">&#9670;&nbsp;</a></span>loopNestBuilder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">mlir::scf::ValueVector</a> mlir::edsc::loopNestBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>fun</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adapters for building loop nests using the builder and the location stored in <a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html" title="Helper class to transparently handle builder insertion points by RAII. ">ScopedContext</a>. </p>
<p>Actual builders are in <a class="el" href="namespacemlir_1_1scf.html#a1e857e851c7fc8a8c7cb7318e8d45ee4" title="Creates a perfect nest of &quot;for&quot; loops, i.e. ">scf::buildLoopNest</a>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00117">117</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCF_8cpp_source.html#l00249">mlir::scf::buildLoopNest()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00057">mlir::edsc::ScopedContext::getContext()</a>, and <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00188">mlir::linalg::generateParallelLoopNest()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00043">insertCopyLoops()</a>, <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00132">loopNestBuilder()</a>, and <a class="el" href="VectorToSCF_8cpp_source.html#l00513">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a6102d86c56239570c27009fc77ccd214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6102d86c56239570c27009fc77ccd214">&#9670;&nbsp;</a></span>loopNestBuilder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">mlir::scf::ValueVector</a> mlir::edsc::loopNestBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>fun</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00132">132</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00117">loopNestBuilder()</a>.</p>

</div>
</div>
<a id="a12538f3de51ace3f31238b03ac803e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12538f3de51ace3f31238b03ac803e6d">&#9670;&nbsp;</a></span>loopNestBuilder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">mlir::scf::ValueVector</a> mlir::edsc::loopNestBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgInitValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">scf::ValueVector</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>fun</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00144">144</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="SCF_8cpp_source.html#l00249">mlir::scf::buildLoopNest()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00057">mlir::edsc::ScopedContext::getContext()</a>, and <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>.</p>

</div>
</div>
<a id="aabb586c240e934aa2564f8fb87ad9f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb586c240e934aa2564f8fb87ad9f92">&#9670;&nbsp;</a></span>makeAffineLoopBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a> mlir::edsc::makeAffineLoopBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new AffineForOp and captures the associated induction variable. </p>
<p>A <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> pointer is passed as the first argument and is the <em>only</em> way to capture the loop induction variable. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00037">37</a> of file <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00375">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00017">emitStaticFor()</a>, <a class="el" href="EDSC_2Builders_8h_source.html#l00120">mlir::edsc::NestedBuilder::enter()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01674">mlir::getForInductionVarOwner()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>, and <a class="el" href="IR_2Builders_8cpp_source.html#l00315">mlir::Builder::getMultiDimIdentityMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00060">mlir::edsc::AffineLoopNestBuilder::AffineLoopNestBuilder()</a>, and <a class="el" href="EDSC_2Builders_8h_source.html#l00169">mlir::edsc::LoopBuilder::getOp()</a>.</p>

</div>
</div>
<a id="aa4e10769efcd438ec5b0f315e186a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e10769efcd438ec5b0f315e186a033">&#9670;&nbsp;</a></span>makeGenericLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::edsc::makeGenericLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#a77f701680752dfb55505285ab8ce8b55">IteratorType</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>regionBuilder</em> = <code><a class="el" href="namespacemlir_1_1edsc.html#a2530abadfa4b280f31ddd2f62d5db514">defaultRegionBuilder</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>otherValues</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>otherAttributes</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>linalg.generic</code> op with the specified <code>inputs</code>, <code>outputs</code> and <code>region</code>. </p>
<p><code>otherValues</code> and <code>otherAttributes</code> may be passed and will be appended as operands and attributes respectively.</p>
<h1>Prerequisites: </h1>
<ol type="1">
<li><code>inputs</code> may contain <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html" title="A StructuredIndexed represents an indexable quantity that is either: ">StructuredIndexed</a> that capture either buffer or tensor values.</li>
<li><code>outputs</code> may contain <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html" title="A StructuredIndexed represents an indexable quantity that is either: ">StructuredIndexed</a> that capture either buffer values or tensor types. If both buffer values and tensor types are present, then all buffer values must appear before any tensor type. Without this restriction output tensor results would need to be reordered, which would result in surprising behavior when combined with region definition. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00073">73</a> of file <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00375">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00696">mlir::IntegerType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00310">mlir::IntegerAttr::get()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00045">mlir::edsc::ScopedContext::getBuilderRef()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00021">mlir::getElementTypeOrSelf()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00051">mlir::edsc::ScopedContext::getLocation()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00160">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00131">mlir::toString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00058">defaultRegionBuilder()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00276">mlir::edsc::ops::linalg_generic_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00310">mlir::edsc::ops::linalg_generic_dilated_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00231">mlir::edsc::ops::linalg_generic_matmul()</a>, and <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00163">mlir::edsc::ops::linalg_generic_pointwise()</a>.</p>

</div>
</div>
<a id="abea7b4f1db20f2062e7cf544465b435e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea7b4f1db20f2062e7cf544465b435e">&#9670;&nbsp;</a></span>makeLoopBuilder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">mlir::edsc::LoopBuilder</a> mlir::edsc::makeLoopBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>iterArgsHandles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgsInitValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new scf::ForOp and captures the associated induction variable. </p>
<p>A <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> pointer is passed as the first argument and is the <em>only</em> way to capture the loop induction variable. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00099">99</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="EDSC_2Builders_8h_source.html#l00120">mlir::edsc::NestedBuilder::enter()</a>, <a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">mlir::scf::getForInductionVarOwner()</a>, and <a class="el" href="EDSC_2Builders_8h_source.html#l00168">mlir::edsc::LoopBuilder::setOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EDSC_2Builders_8h_source.html#l00169">mlir::edsc::LoopBuilder::getOp()</a>, <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00040">mlir::edsc::LoopNestBuilder::LoopNestBuilder()</a>, and <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8h_source.html#l00040">makeLoopBuilder()</a>.</p>

</div>
</div>
<a id="a87caf90e4c0e1327e9102ffd746d77f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87caf90e4c0e1327e9102ffd746d77f2">&#9670;&nbsp;</a></span>makeLoopBuilder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a> mlir::edsc::makeLoopBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8h_source.html#l00040">40</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8h_source.html">Builders.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00099">makeLoopBuilder()</a>.</p>

</div>
</div>
<a id="ae731f984bb316abc10bf03d3455e952c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae731f984bb316abc10bf03d3455e952c">&#9670;&nbsp;</a></span>makeParallelLoopBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a> mlir::edsc::makeParallelLoopBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new scf::ParallelOp and captures the associated induction variables. </p>
<p>An array of <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> pointers is passed as the first argument and is the <em>only</em> way to capture loop induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00083">83</a> of file <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="EDSC_2Builders_8h_source.html#l00120">mlir::edsc::NestedBuilder::enter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EDSC_2Builders_8h_source.html#l00169">mlir::edsc::LoopBuilder::getOp()</a>, and <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00017">mlir::edsc::ParallelLoopNestBuilder::ParallelLoopNestBuilder()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 17 2020 16:27:49 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
